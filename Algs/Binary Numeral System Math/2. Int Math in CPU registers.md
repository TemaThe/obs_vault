###### Sum Binary Numbers
$$
\Large
\begin{array}{r}
+
\begin{array}{r}
1001 \\
0011\\
\end{array} \\
\hline
\begin{array}{r}
1100
\end{array}
\end{array}
$$
##### Subtraction bin numbers
I

$$
\Large
\begin{array}{r}
-
\begin{array}{r}
1001 \\
0011\\
\end{array} \\
\hline
\begin{array}{r}
 100
\end{array}
\end{array}
$$

###### CPU Register

Register - physical memory inside CPU.
Can be from up to 32/64 bit size.
most significant bit, MSb or high-order bit(most left)
lest significant bit , LSb or low-order bit(most right)

Numbers in PC can be divided
- Unsigned Int
- Signed Int

**Subtraction is just sum with negative number**

Goal - 

![[Pasted image 20240129170401.png|300]]
```kotlin
(x+9) mod 10 = x - 1
(2+9) mod 10 = 2 - 1
```

![[Pasted image 20240129171820.png|300]]
```kotlin
x + y: (x + y) mod 10
: means emulate
1 + 2: (1 + 2) mod 10 = 3
2 + 4: (2 + 4) mod 10 = -4 (overflow !)
```


![[Pasted image 20240129175311.png]]
```kotlin
Math
-x + -y = -1 + -3 = -4

Emulation in CPU registers
-1 = 9 
9 - 3 = 6
6 = -4
```


###### Important !!!
 We need to assign particular positive numbers
to treat as negative to make this scheme work.

```kotlin
"Negative plus Negative"
- x + -y emulates (k+z) mod 10
k&z - correspond to -x and -y
-1 - 3 => (9 + 7) % 10 = 6 => -4 
```

```kotlin
"Negative plus Positive"
-x + y emulates (k + y) mod 10
k&z - correspond to -x and -y
```
![[Pasted image 20240129180534.png|300]]|

| Original | Interpretation |
| :--: | :--: |
| 0-5 | 0..5 |
| 6-9 | -4..-1 |
| 9 | -1 |

###### Sum with positive

```kotlin **Sum of positive**
1+3
1 eq 1 and 3 eq 3
(1+3) mod 10 = 4
4 eq 4
display 4
```

Sum with negative

```kotlin
-2+1
-2->8
1->1
(8+1) mod 10 =9
9->-1
display -1
```

Need to know max positive number to know when overflow happen. 

```kotlin
-x = (m - 1) - x + 1
(m-1) - size of register
```

###### Binary subtraction via sum 

```kotlin
-x = 11..11 - x + 1
```

##### Subtraction bin numbers


$$
\Large
\begin{array}{r}
-
\begin{array}{r}
1111 \\
0101\\
\end{array} \\
\hline
\begin{array}{r}
 1010
\end{array}
\end{array}
$$
!!! Invert !!!

```kotlin
-x = invert(x) + 1
```

One' complement method(only inversion)
%%first complement is inversion, second is add one %%
%%one's complement -x=invert(x)
two zero and additional + 1 operation %%

| Bits | Unsigned value | Ones' complement |
| ---- | ---- | ---- |
| **0**00 | 0 | 0 |
| **0**01 | 1 | 1 |
| **0**10 | 2 | 2 |
| **0**11 | 3 | 3 |
| **1**00 | 4 | −3 |
| **1**01 | 5 | −2 |
| **1**10 | 6 | −1 |
| **1**11 | 7 | −0 |
```kotlin
-3 + 3 = (011 + 100 + 1) mod 1000 = 1000 -> 
display 000
```

High bit is sing bit

Let's add this +1 to table -
###### Two compliment method

| Bits | Unsigned value | Ones' complement   |
| ---- | ---- | ---- |
| **0**00 | 0 | 0 |
| **0**01 | 1 | 1 |
| **0**10 | 2 | 2 |
| **0**11 | 3 | 3 |
| **1**00 | 4 | −4 |
| **1**01 | 5 | −3 |
| **1**10 | 6 | −2 |
| **1**11 | 7 | −1 |


```kotlin
-3 + 3 = (101 + 011) mod 1000 = "0"000
display 0

-1-3 = (111+101) mod 1000 = 1100 = "1"100
display -4 
// high bit is 1

3 + 1 = (011+001) mod 1000="0"100 -> 4 
//high bit is zero

3+3=(011+011)mod 1000 = "0"110

-4 + -4 = (100+100) mod 1000 = "1"000 = 0???
//overflow happen or -000 ? or -8???
```

$$
\Large
\begin{array}{r}
-
\begin{array}{r}
111 \\
101\\
\end{array} \\
\hline
\begin{array}{r}
 1100
\end{array}
\end{array}
$$
$$\begin{aligned}
-3_{10} + 2_{10} = -1_{10}\\
3_{10}=011\\
-3 = invert(011_2)+1=101_2\\
(101_2+010_{2})\%1000=0111_2=-1_{10}
\end{aligned}$$

###### Integer number boarders
N is max register size

$$Max\ Integer = 
2^{N-1}\ -\ 1$$

$$Min\ Integer = 
-2^{N-1}$$

Negative number range is greater then positive by one.

###### Compare Bin with diff sign
$$ \begin{flalign} 
3_{10}=011_2\\
-2_{10}=110_2\\
&& \end{flalign} 
$$
To compare need to ignore high sign bit